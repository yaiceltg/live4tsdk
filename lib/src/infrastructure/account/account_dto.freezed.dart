// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'account_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
AccountDto _$AccountDtoFromJson(Map<String, dynamic> json) {
  return _AccountDto.fromJson(json);
}

/// @nodoc
class _$AccountDtoTearOff {
  const _$AccountDtoTearOff();

// ignore: unused_element
  _AccountDto call(
      {int id,
      String name,
      String lastName,
      int typeUser,
      String address,
      String picture,
      String phone,
      String idNumber,
      String userName,
      String email,
      String parent,
      String parentPhone,
      String experience,
      DateTime emailVerifiedAt,
      DateTime createdAt,
      DateTime updatedAt}) {
    return _AccountDto(
      id: id,
      name: name,
      lastName: lastName,
      typeUser: typeUser,
      address: address,
      picture: picture,
      phone: phone,
      idNumber: idNumber,
      userName: userName,
      email: email,
      parent: parent,
      parentPhone: parentPhone,
      experience: experience,
      emailVerifiedAt: emailVerifiedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

// ignore: unused_element
  AccountDto fromJson(Map<String, Object> json) {
    return AccountDto.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AccountDto = _$AccountDtoTearOff();

/// @nodoc
mixin _$AccountDto {
  int get id;
  String get name;
  String get lastName;
  int get typeUser;
  String get address;
  String get picture;
  String get phone;
  String get idNumber;
  String get userName;
  String get email;
  String get parent;
  String get parentPhone;
  String get experience;
  DateTime get emailVerifiedAt;
  DateTime get createdAt;
  DateTime get updatedAt;

  Map<String, dynamic> toJson();
  @JsonKey(ignore: true)
  $AccountDtoCopyWith<AccountDto> get copyWith;
}

/// @nodoc
abstract class $AccountDtoCopyWith<$Res> {
  factory $AccountDtoCopyWith(
          AccountDto value, $Res Function(AccountDto) then) =
      _$AccountDtoCopyWithImpl<$Res>;
  $Res call(
      {int id,
      String name,
      String lastName,
      int typeUser,
      String address,
      String picture,
      String phone,
      String idNumber,
      String userName,
      String email,
      String parent,
      String parentPhone,
      String experience,
      DateTime emailVerifiedAt,
      DateTime createdAt,
      DateTime updatedAt});
}

/// @nodoc
class _$AccountDtoCopyWithImpl<$Res> implements $AccountDtoCopyWith<$Res> {
  _$AccountDtoCopyWithImpl(this._value, this._then);

  final AccountDto _value;
  // ignore: unused_field
  final $Res Function(AccountDto) _then;

  @override
  $Res call({
    Object id = freezed,
    Object name = freezed,
    Object lastName = freezed,
    Object typeUser = freezed,
    Object address = freezed,
    Object picture = freezed,
    Object phone = freezed,
    Object idNumber = freezed,
    Object userName = freezed,
    Object email = freezed,
    Object parent = freezed,
    Object parentPhone = freezed,
    Object experience = freezed,
    Object emailVerifiedAt = freezed,
    Object createdAt = freezed,
    Object updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as int,
      name: name == freezed ? _value.name : name as String,
      lastName: lastName == freezed ? _value.lastName : lastName as String,
      typeUser: typeUser == freezed ? _value.typeUser : typeUser as int,
      address: address == freezed ? _value.address : address as String,
      picture: picture == freezed ? _value.picture : picture as String,
      phone: phone == freezed ? _value.phone : phone as String,
      idNumber: idNumber == freezed ? _value.idNumber : idNumber as String,
      userName: userName == freezed ? _value.userName : userName as String,
      email: email == freezed ? _value.email : email as String,
      parent: parent == freezed ? _value.parent : parent as String,
      parentPhone:
          parentPhone == freezed ? _value.parentPhone : parentPhone as String,
      experience:
          experience == freezed ? _value.experience : experience as String,
      emailVerifiedAt: emailVerifiedAt == freezed
          ? _value.emailVerifiedAt
          : emailVerifiedAt as DateTime,
      createdAt:
          createdAt == freezed ? _value.createdAt : createdAt as DateTime,
      updatedAt:
          updatedAt == freezed ? _value.updatedAt : updatedAt as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$AccountDtoCopyWith<$Res> implements $AccountDtoCopyWith<$Res> {
  factory _$AccountDtoCopyWith(
          _AccountDto value, $Res Function(_AccountDto) then) =
      __$AccountDtoCopyWithImpl<$Res>;
  @override
  $Res call(
      {int id,
      String name,
      String lastName,
      int typeUser,
      String address,
      String picture,
      String phone,
      String idNumber,
      String userName,
      String email,
      String parent,
      String parentPhone,
      String experience,
      DateTime emailVerifiedAt,
      DateTime createdAt,
      DateTime updatedAt});
}

/// @nodoc
class __$AccountDtoCopyWithImpl<$Res> extends _$AccountDtoCopyWithImpl<$Res>
    implements _$AccountDtoCopyWith<$Res> {
  __$AccountDtoCopyWithImpl(
      _AccountDto _value, $Res Function(_AccountDto) _then)
      : super(_value, (v) => _then(v as _AccountDto));

  @override
  _AccountDto get _value => super._value as _AccountDto;

  @override
  $Res call({
    Object id = freezed,
    Object name = freezed,
    Object lastName = freezed,
    Object typeUser = freezed,
    Object address = freezed,
    Object picture = freezed,
    Object phone = freezed,
    Object idNumber = freezed,
    Object userName = freezed,
    Object email = freezed,
    Object parent = freezed,
    Object parentPhone = freezed,
    Object experience = freezed,
    Object emailVerifiedAt = freezed,
    Object createdAt = freezed,
    Object updatedAt = freezed,
  }) {
    return _then(_AccountDto(
      id: id == freezed ? _value.id : id as int,
      name: name == freezed ? _value.name : name as String,
      lastName: lastName == freezed ? _value.lastName : lastName as String,
      typeUser: typeUser == freezed ? _value.typeUser : typeUser as int,
      address: address == freezed ? _value.address : address as String,
      picture: picture == freezed ? _value.picture : picture as String,
      phone: phone == freezed ? _value.phone : phone as String,
      idNumber: idNumber == freezed ? _value.idNumber : idNumber as String,
      userName: userName == freezed ? _value.userName : userName as String,
      email: email == freezed ? _value.email : email as String,
      parent: parent == freezed ? _value.parent : parent as String,
      parentPhone:
          parentPhone == freezed ? _value.parentPhone : parentPhone as String,
      experience:
          experience == freezed ? _value.experience : experience as String,
      emailVerifiedAt: emailVerifiedAt == freezed
          ? _value.emailVerifiedAt
          : emailVerifiedAt as DateTime,
      createdAt:
          createdAt == freezed ? _value.createdAt : createdAt as DateTime,
      updatedAt:
          updatedAt == freezed ? _value.updatedAt : updatedAt as DateTime,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AccountDto extends _AccountDto {
  const _$_AccountDto(
      {this.id,
      this.name,
      this.lastName,
      this.typeUser,
      this.address,
      this.picture,
      this.phone,
      this.idNumber,
      this.userName,
      this.email,
      this.parent,
      this.parentPhone,
      this.experience,
      this.emailVerifiedAt,
      this.createdAt,
      this.updatedAt})
      : super._();

  factory _$_AccountDto.fromJson(Map<String, dynamic> json) =>
      _$_$_AccountDtoFromJson(json);

  @override
  final int id;
  @override
  final String name;
  @override
  final String lastName;
  @override
  final int typeUser;
  @override
  final String address;
  @override
  final String picture;
  @override
  final String phone;
  @override
  final String idNumber;
  @override
  final String userName;
  @override
  final String email;
  @override
  final String parent;
  @override
  final String parentPhone;
  @override
  final String experience;
  @override
  final DateTime emailVerifiedAt;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;

  @override
  String toString() {
    return 'AccountDto(id: $id, name: $name, lastName: $lastName, typeUser: $typeUser, address: $address, picture: $picture, phone: $phone, idNumber: $idNumber, userName: $userName, email: $email, parent: $parent, parentPhone: $parentPhone, experience: $experience, emailVerifiedAt: $emailVerifiedAt, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AccountDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.typeUser, typeUser) ||
                const DeepCollectionEquality()
                    .equals(other.typeUser, typeUser)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.picture, picture) ||
                const DeepCollectionEquality()
                    .equals(other.picture, picture)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.parent, parent) ||
                const DeepCollectionEquality().equals(other.parent, parent)) &&
            (identical(other.parentPhone, parentPhone) ||
                const DeepCollectionEquality()
                    .equals(other.parentPhone, parentPhone)) &&
            (identical(other.experience, experience) ||
                const DeepCollectionEquality()
                    .equals(other.experience, experience)) &&
            (identical(other.emailVerifiedAt, emailVerifiedAt) ||
                const DeepCollectionEquality()
                    .equals(other.emailVerifiedAt, emailVerifiedAt)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(typeUser) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(picture) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(idNumber) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(parent) ^
      const DeepCollectionEquality().hash(parentPhone) ^
      const DeepCollectionEquality().hash(experience) ^
      const DeepCollectionEquality().hash(emailVerifiedAt) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt);

  @JsonKey(ignore: true)
  @override
  _$AccountDtoCopyWith<_AccountDto> get copyWith =>
      __$AccountDtoCopyWithImpl<_AccountDto>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AccountDtoToJson(this);
  }
}

abstract class _AccountDto extends AccountDto {
  const _AccountDto._() : super._();
  const factory _AccountDto(
      {int id,
      String name,
      String lastName,
      int typeUser,
      String address,
      String picture,
      String phone,
      String idNumber,
      String userName,
      String email,
      String parent,
      String parentPhone,
      String experience,
      DateTime emailVerifiedAt,
      DateTime createdAt,
      DateTime updatedAt}) = _$_AccountDto;

  factory _AccountDto.fromJson(Map<String, dynamic> json) =
      _$_AccountDto.fromJson;

  @override
  int get id;
  @override
  String get name;
  @override
  String get lastName;
  @override
  int get typeUser;
  @override
  String get address;
  @override
  String get picture;
  @override
  String get phone;
  @override
  String get idNumber;
  @override
  String get userName;
  @override
  String get email;
  @override
  String get parent;
  @override
  String get parentPhone;
  @override
  String get experience;
  @override
  DateTime get emailVerifiedAt;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  @JsonKey(ignore: true)
  _$AccountDtoCopyWith<_AccountDto> get copyWith;
}
