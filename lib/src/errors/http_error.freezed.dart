// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'http_error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$HttpErrorTearOff {
  const _$HttpErrorTearOff();

// ignore: unused_element
  _Internal internal() {
    return const _Internal();
  }

// ignore: unused_element
  _NotFound notFound() {
    return const _NotFound();
  }

// ignore: unused_element
  _AccessDenied accessDenied() {
    return const _AccessDenied();
  }

// ignore: unused_element
  _Undefined undefined() {
    return const _Undefined();
  }

// ignore: unused_element
  _Forbidden forbidden() {
    return const _Forbidden();
  }

// ignore: unused_element
  _BadRequest badRequest() {
    return const _BadRequest();
  }
}

/// @nodoc
// ignore: unused_element
const $HttpError = _$HttpErrorTearOff();

/// @nodoc
mixin _$HttpError {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $HttpErrorCopyWith<$Res> {
  factory $HttpErrorCopyWith(HttpError value, $Res Function(HttpError) then) =
      _$HttpErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$HttpErrorCopyWithImpl<$Res> implements $HttpErrorCopyWith<$Res> {
  _$HttpErrorCopyWithImpl(this._value, this._then);

  final HttpError _value;
  // ignore: unused_field
  final $Res Function(HttpError) _then;
}

/// @nodoc
abstract class _$InternalCopyWith<$Res> {
  factory _$InternalCopyWith(_Internal value, $Res Function(_Internal) then) =
      __$InternalCopyWithImpl<$Res>;
}

/// @nodoc
class __$InternalCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$InternalCopyWith<$Res> {
  __$InternalCopyWithImpl(_Internal _value, $Res Function(_Internal) _then)
      : super(_value, (v) => _then(v as _Internal));

  @override
  _Internal get _value => super._value as _Internal;
}

/// @nodoc
class _$_Internal implements _Internal {
  const _$_Internal();

  @override
  String toString() {
    return 'HttpError.internal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Internal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return internal();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (internal != null) {
      return internal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return internal(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (internal != null) {
      return internal(this);
    }
    return orElse();
  }
}

abstract class _Internal implements HttpError {
  const factory _Internal() = _$_Internal;
}

/// @nodoc
abstract class _$NotFoundCopyWith<$Res> {
  factory _$NotFoundCopyWith(_NotFound value, $Res Function(_NotFound) then) =
      __$NotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotFoundCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$NotFoundCopyWith<$Res> {
  __$NotFoundCopyWithImpl(_NotFound _value, $Res Function(_NotFound) _then)
      : super(_value, (v) => _then(v as _NotFound));

  @override
  _NotFound get _value => super._value as _NotFound;
}

/// @nodoc
class _$_NotFound implements _NotFound {
  const _$_NotFound();

  @override
  String toString() {
    return 'HttpError.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _NotFound implements HttpError {
  const factory _NotFound() = _$_NotFound;
}

/// @nodoc
abstract class _$AccessDeniedCopyWith<$Res> {
  factory _$AccessDeniedCopyWith(
          _AccessDenied value, $Res Function(_AccessDenied) then) =
      __$AccessDeniedCopyWithImpl<$Res>;
}

/// @nodoc
class __$AccessDeniedCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$AccessDeniedCopyWith<$Res> {
  __$AccessDeniedCopyWithImpl(
      _AccessDenied _value, $Res Function(_AccessDenied) _then)
      : super(_value, (v) => _then(v as _AccessDenied));

  @override
  _AccessDenied get _value => super._value as _AccessDenied;
}

/// @nodoc
class _$_AccessDenied implements _AccessDenied {
  const _$_AccessDenied();

  @override
  String toString() {
    return 'HttpError.accessDenied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _AccessDenied);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return accessDenied();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (accessDenied != null) {
      return accessDenied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return accessDenied(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (accessDenied != null) {
      return accessDenied(this);
    }
    return orElse();
  }
}

abstract class _AccessDenied implements HttpError {
  const factory _AccessDenied() = _$_AccessDenied;
}

/// @nodoc
abstract class _$UndefinedCopyWith<$Res> {
  factory _$UndefinedCopyWith(
          _Undefined value, $Res Function(_Undefined) then) =
      __$UndefinedCopyWithImpl<$Res>;
}

/// @nodoc
class __$UndefinedCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$UndefinedCopyWith<$Res> {
  __$UndefinedCopyWithImpl(_Undefined _value, $Res Function(_Undefined) _then)
      : super(_value, (v) => _then(v as _Undefined));

  @override
  _Undefined get _value => super._value as _Undefined;
}

/// @nodoc
class _$_Undefined implements _Undefined {
  const _$_Undefined();

  @override
  String toString() {
    return 'HttpError.undefined()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Undefined);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return undefined();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (undefined != null) {
      return undefined();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return undefined(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (undefined != null) {
      return undefined(this);
    }
    return orElse();
  }
}

abstract class _Undefined implements HttpError {
  const factory _Undefined() = _$_Undefined;
}

/// @nodoc
abstract class _$ForbiddenCopyWith<$Res> {
  factory _$ForbiddenCopyWith(
          _Forbidden value, $Res Function(_Forbidden) then) =
      __$ForbiddenCopyWithImpl<$Res>;
}

/// @nodoc
class __$ForbiddenCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$ForbiddenCopyWith<$Res> {
  __$ForbiddenCopyWithImpl(_Forbidden _value, $Res Function(_Forbidden) _then)
      : super(_value, (v) => _then(v as _Forbidden));

  @override
  _Forbidden get _value => super._value as _Forbidden;
}

/// @nodoc
class _$_Forbidden implements _Forbidden {
  const _$_Forbidden();

  @override
  String toString() {
    return 'HttpError.forbidden()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Forbidden);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return forbidden();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (forbidden != null) {
      return forbidden();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return forbidden(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (forbidden != null) {
      return forbidden(this);
    }
    return orElse();
  }
}

abstract class _Forbidden implements HttpError {
  const factory _Forbidden() = _$_Forbidden;
}

/// @nodoc
abstract class _$BadRequestCopyWith<$Res> {
  factory _$BadRequestCopyWith(
          _BadRequest value, $Res Function(_BadRequest) then) =
      __$BadRequestCopyWithImpl<$Res>;
}

/// @nodoc
class __$BadRequestCopyWithImpl<$Res> extends _$HttpErrorCopyWithImpl<$Res>
    implements _$BadRequestCopyWith<$Res> {
  __$BadRequestCopyWithImpl(
      _BadRequest _value, $Res Function(_BadRequest) _then)
      : super(_value, (v) => _then(v as _BadRequest));

  @override
  _BadRequest get _value => super._value as _BadRequest;
}

/// @nodoc
class _$_BadRequest implements _BadRequest {
  const _$_BadRequest();

  @override
  String toString() {
    return 'HttpError.badRequest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BadRequest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult internal(),
    @required TResult notFound(),
    @required TResult accessDenied(),
    @required TResult undefined(),
    @required TResult forbidden(),
    @required TResult badRequest(),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return badRequest();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult internal(),
    TResult notFound(),
    TResult accessDenied(),
    TResult undefined(),
    TResult forbidden(),
    TResult badRequest(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (badRequest != null) {
      return badRequest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult internal(_Internal value),
    @required TResult notFound(_NotFound value),
    @required TResult accessDenied(_AccessDenied value),
    @required TResult undefined(_Undefined value),
    @required TResult forbidden(_Forbidden value),
    @required TResult badRequest(_BadRequest value),
  }) {
    assert(internal != null);
    assert(notFound != null);
    assert(accessDenied != null);
    assert(undefined != null);
    assert(forbidden != null);
    assert(badRequest != null);
    return badRequest(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult internal(_Internal value),
    TResult notFound(_NotFound value),
    TResult accessDenied(_AccessDenied value),
    TResult undefined(_Undefined value),
    TResult forbidden(_Forbidden value),
    TResult badRequest(_BadRequest value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (badRequest != null) {
      return badRequest(this);
    }
    return orElse();
  }
}

abstract class _BadRequest implements HttpError {
  const factory _BadRequest() = _$_BadRequest;
}
